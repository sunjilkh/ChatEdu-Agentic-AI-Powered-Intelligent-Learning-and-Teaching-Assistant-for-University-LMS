{
  "test_summary": {
    "timestamp": "2025-08-06T19:42:51.121851",
    "total_tests": 23,
    "passed": 18,
    "failed": 5,
    "pass_rate": 78.26,
    "average_response_time": 6.62,
    "language_breakdown": {
      "english": {
        "total": 12,
        "passed": 8,
        "pass_rate": 66.67
      },
      "bangla": {
        "total": 11,
        "passed": 10,
        "pass_rate": 90.91
      }
    },
    "confidence_distribution": {
      "HIGH": 18,
      "MEDIUM": 0,
      "LOW": 0
    }
  },
  "detailed_results": [
    {
      "test_id": "algo_001_en",
      "question": "What is an algorithm?",
      "expected_answer": "A finite sequence of instructions for solving a problem or computational procedure",
      "actual_answer": "An algorithm is a set of instructions or steps that a computer program follows to solve a specific problem or perform a particular task. It is a step-by-step procedure for solving a problem, and it can be used to automate repetitive tasks or to solve complex problems in a structured manner. Algorithms are essential for many computing technologies, including programming languages, operating systems, and data processing systems. They provide a clear and concise way to describe the steps needed to solve a problem, making them an important tool for programmers and computer scientists.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe an algorithm as a finite sequence of instructions for solving problems or performing tasks. The actual answer provides additional context about the role and importance of algorithms in computing, which aligns with the expected answer's core concept that an algorithm is a step-by-step procedure for solving problems. The descriptions are semantically equivalent, and any minor differences in wording do not alter the fundamental meaning conveyed by both answers. Both answers also implicitly acknowledge that algorithms can be used to automate tasks, which is a key aspect of their function. The factual information about the purpose and application of algorithms in computing technologies is consistent between both answers.",
      "response_time": 5.955408811569214,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        25,
        23,
        34
      ],
      "language": "english"
    },
    {
      "test_id": "sort_001_en",
      "question": "How does merge sort work?",
      "expected_answer": "Merge sort divides array into halves, recursively sorts them, then merges sorted halves",
      "actual_answer": "Merge sort is a divide-and-conquer algorithm that recursively divides the input array into smaller subarrays, sorts them individually, and then merges them back together in sorted order. It uses a merge step to combine the sorted subarrays into a single sorted array.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe the merge sort algorithm's process of dividing an array, sorting the resulting subarrays recursively, and merging them back together in sorted order. The actual answer provides more detail about how merge sort divides the array into smaller subarrays and uses a merge step, but it does not change the core meaning conveyed in the expected answer. The descriptions are semantically equivalent despite minor differences in wording and potential language translation issues, which do not affect the factual information conveyed about merge sort.",
      "response_time": 4.300492763519287,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        50,
        36,
        60
      ],
      "language": "english"
    },
    {
      "test_id": "complexity_001_en",
      "question": "What is the time complexity of quicksort?",
      "expected_answer": "Average case O(n log n), worst case O(n²)",
      "actual_answer": "The time complexity of quicksort is O(n log n).",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the time complexity of quicksort, which is a key concept. The expected answer provides average and worst-case complexities explicitly as O(n log n) and O(n²), respectively, while the actual answer mentions only the average case complexity. However, it is understood that the worst-case scenario would naturally be O(n²). The factual information about quicksort'in time complexities remains consistent between both answers. Minor differences in wording do not affect the core meaning, and since both are likely to be in English, cross-language consistency is not a concern here.",
      "response_time": 3.264125108718872,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        190,
        200,
        201
      ],
      "language": "english"
    },
    {
      "test_id": "ds_001_en",
      "question": "What is a binary search tree?",
      "expected_answer": "A binary tree where left subtree values are less than node, right subtree values are greater",
      "actual_answer": "A binary search tree is a type of tree data structure where the nodes are organized in a way that allows for efficient searching, insertion, and deletion operations. In a binary search tree, each node has at most two children, and the left child of a node is always less than or equal to the node's value, while the right child is always greater than or equal to the node's value. This property allows for quick comparisons and traversals of the tree.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer succinctly describes a binary search tree's property regarding the ordering of values in its subtrees. However, the actual answer provides additional details about node relationships and operations (searching, insertion, deletion) that are not mentioned in the expected answer but do not contradict it. The actual answer also includes a broader explanation of how this property allows for efficient operations, which is beyond what the expected answer conveys. While both answers describe the same core concept (the ordering of values in a binary search tree), they do so with different levels of detail and context, leading to a judgment of non-equivalence.",
      "response_time": 5.493687152862549,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        307,
        306,
        309
      ],
      "language": "english"
    },
    {
      "test_id": "dp_001_en",
      "question": "What is dynamic programming?",
      "expected_answer": "An algorithmic technique that solves problems by breaking them into overlapping subproblems",
      "actual_answer": "Dynamic programming, like the divide-and-conquer method, solves problems by combining the solutions to subproblems.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer describes an algorithmic technique that solves problems by breaking them into overlapping subproblems, which is a characteristic of dynamic programming. However, the actual answer incorrectly states that dynamic programming combines solutions to subproblems, which aligns more with the divide-and-conquer method. Divide-and-conquer breaks problems into non-overlapping subproblems, whereas dynamic programming solves overlapping subproblems and stores their solutions. Therefore, the two answers do not convey the same core information about how these techniques work.",
      "response_time": 3.527418851852417,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        379,
        379,
        399
      ],
      "language": "english"
    },
    {
      "test_id": "algo_001_bn",
      "question": "অ্যালগরিদম কি?",
      "expected_answer": "অ্যালগরিদম হল একটি সমস্যা সমাধানের জন্য নির্দিষ্ট নির্দেশাবলীর একটি ক্রম",
      "actual_answer": "অ্যালগরিদম হলো একটি সংজ্ঞাপনা যা কোন কাজের উপর ভিত্তি করে একটি সংজ্ঞা বা পদ্ধতি দেয়। এটি কোন সমস্যার উপর ভিত্তি করে একটি সংজ্ঞা বা পদ্ধতি দেয়। অ্যালগরিদম একটি সংজ্ঞা বা",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe an algorithm as a distinct unit within the context of problem-solving or task execution. The first answer in Bangla and the second in English convey that algorithms are specialized units designed for specific tasks within a broader context, which is consistent with factual information about RAG systems. Minor differences in wording do not alter the core meaning conveyed by both answers. Cross-language consistency is maintained, and the essence of what an algorithm represents within RAG systems is effectively communicated in both languages.",
      "response_time": 10.10286021232605,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        25,
        23,
        34
      ],
      "language": "bangla"
    },
    {
      "test_id": "sort_001_bn",
      "question": "মার্জ সর্ট কিভাবে কাজ করে?",
      "expected_answer": "মার্জ সর্ট অ্যারেকে অংশে ভাগ করে, প্রতিটি অংশ আলাদাভাবে সাজায়, তারপর সেগুলো একত্রিত করে",
      "actual_answer": "মার্জ সর্ট একটি প্রোগ্রাম করে যা আর্টিফিশিয়াল ইন্টেলিজেন্সের উপর ভিত্তি করে। এটি দুটি বিভাগের মধ্যে সম্পর্ক রাখার জন্য একটি প্রোগ্রাম তৈরি করে। আর সেই প্রোগ্রামটি একটি নতুন",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe the same core concept of Mr. Sanders setting up a program within Facebook's infrastructure, where each subsection operates semi-autonomously and communicates with its neighboring sections. The actual answer provides additional context about the program's purpose, which is not essential to understanding the core information but does not contradict it either. Both answers are in English and convey the same meaning despite differences in wording and structure, thus maintaining cross-language consistency.",
      "response_time": 10.2442307472229,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        50,
        36,
        54
      ],
      "language": "bangla"
    },
    {
      "test_id": "complexity_001_bn",
      "question": "কুইকসর্টের সময় জটিলতা কত?",
      "expected_answer": "গড় ক্ষেত্রে O(n log n), সবচেয়ে খারাপ ক্ষেত্রে O(n²)",
      "actual_answer": "কুইকসর্টের সময় জটিলতা ।n2/।",
      "success": true,
      "equivalent": false,
      "confidence": "LOW",
      "explanation": "The expected answer clearly states the time complexities for two different operations within a sorted array, O(n log n) and O(n²). In contrast, the actual answer is in Bangla and does not mention time complexities. Instead, it refers to a \"queue\" (কুইকসর্টের সময়) and uses the term \"khayapoktô\" (খারাপ ক্ষেত্রে), which translates to 'in the safe zone' or 'securely'. The actual answer fails to convey the same key concepts and factual information as the expected one, hence it is not semantically equivalent.",
      "response_time": 5.228049993515015,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        210,
        201,
        190
      ],
      "language": "bangla"
    },
    {
      "test_id": "ds_001_bn",
      "question": "বাইনারি সার্চ ট্রি কি?",
      "expected_answer": "একটি বাইনারি ট্রি যেখানে বাম সাবট্রিতে ছোট মান এবং ডান সাবট্রিতে বড় মান থাকে",
      "actual_answer": "বাইনারি সার্চ ট্রি (Binary Search Tree) একটি প্রোগ্রামিং সার্চ ট্রি যা অন্তর্ভুক্ত করে এবং সার্চ করার জন্য বিশ্লেষণ করা হয়। এটি সার্চ করার জন্য প্রথমে অন্তর্ভুক্ত সংখ্যাটি সার্চ করা হয়, এ",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe a Binary Search Tree (BST) and its properties of maintaining sorted elements with the ability to perform insertions and lookups efficiently. The first answer is in Bangla, while the second one is in English but conveys the same essential information about BSTs being programmed data structures that maintain sorted order and allow for efficient insertion and search operations. The core concepts of a Binary Search Tree are accurately represented in both answers, with only minor differences in language expression that do not alter the meaning or factual content.",
      "response_time": 9.981075048446655,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        307,
        306,
        309
      ],
      "language": "bangla"
    },
    {
      "test_id": "dp_001_bn",
      "question": "ডাইনামিক প্রোগ্রামিং কি?",
      "expected_answer": "একটি অ্যালগরিদমিক পদ্ধতি যা সমস্যাকে ছোট উপ-সমস্যায় ভাগ করে সমাধান করে",
      "actual_answer": "ডাইনামিক প্রোগ্রামিং, বিশেষ করে দিন ও সাউন্ড প্রোগ্রামিং, একটি প্রোগ্রামিং তরিকা ব্যবহার করে সমস্যাগুলি সমাধান করা হয়। এটি সমস্যাগুলিকে বিভিন্ন উপাদানের মধ্যে বিভাজন করা এব",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the role of a digital platform in facilitating community support for disaster relief efforts. The first answer is in Bangla, while the second one is in English but conveys the same meaning about digital platforms enabling diverse forms of assistance within communities. The core concepts and factual information are consistent across both answers, with only minor differences in wording that do not affect the overall meaning.",
      "response_time": 8.668358087539673,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        379,
        379,
        399
      ],
      "language": "bangla"
    },
    {
      "test_id": "textbook_001_en",
      "question": "What is asymptotic notation?",
      "expected_answer": "Mathematical notation used to describe the limiting behavior of functions, commonly used for algorithm analysis",
      "actual_answer": "Asymptotic notation is a way of expressing the behavior of a function as it approaches infinity. It involves using symbols such as ∞, 0, or ±∞ to indicate that the function is approaching a specific value or limit. This notation is often used in mathematics and computer science to simplify and analyze large numbers or complex functions.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the concept of asymptotic notation, which is used to describe the behavior of functions as they approach a limit. The expected answer focuses on its use in algorithm analysis, while the actual answer provides more detail about how it is used to express function behavior as they approach infinity. Despite slight differences in wording and additional details provided in the actual answer, both convey the same key concepts about asymptotic notation' end use in mathematics and computer science. The factual information is consistent between the two answers, with no discrepancies that would alter the understanding of asymptotic notation's purpose and application. Both answers are in English, ensuring cross-language consistency is not a concern here.",
      "response_time": 4.822098255157471,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        64,
        67,
        65
      ],
      "language": "english"
    },
    {
      "test_id": "textbook_001_bn",
      "question": "অ্যাসিম্পটোটিক নোটেশন কি?",
      "expected_answer": "ফাংশনের সীমাবদ্ধতা বর্ণনার জন্য ব্যবহৃত গাণিতিক নোটেশন যা অ্যালগরিদম বিশ্লেষণে ব্যবহৃত হয়",
      "actual_answer": "অ্যাসিম্পটোটিক নোটেশন একটি বিশেষ নোটেশন যা সম্পর্কে অনুসারে বিভিন্ন ধারণা থাকে। এটি সম্পর্কে বিভিন্ন ধারণা থাকে, যেমন সংখ্যা বা প্রতিশত দৈর্ঘ্য অনুযায়ী সম্পর্কে বিভিন্ন ধ",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the importance of normalization in functions, which is a key concept. The first answer emphasizes that this normalization process is an essential consideration within the algorithm and its implementation. The second answer also highlights the significance of normalization, stating it as a specific subroutine that receives various types of inputs (numerical values or strings) and outputs standardized data. Despite the difference in wording, both answers convey the same fundamental message about normalization' end importance within algorithms. The minor differences in language do not affect the core meaning and factual consistency of the information provided.",
      "response_time": 8.34524655342102,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        65,
        64,
        67
      ],
      "language": "bangla"
    },
    {
      "test_id": "heap_001_en",
      "question": "How do you maintain the heap property?",
      "expected_answer": "Use heapify operations to ensure parent nodes satisfy heap property relative to children",
      "actual_answer": "To maintain the heap property, we need to ensure that each node in the heap is greater than or equal to its children. This means that for any node i in the heap, the value of the node at index i is greater than or equal to the values of all nodes at indices 2i, 2i+1, and 2i+2 in the heap. This property is known as the heap property or heap invariant.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the same key concept of maintaining the heap property within a binary heap data structure. The expected answer simplifies this idea by suggesting that parent nodes should satisfy the heap property relative to their children, which is achieved through heapify operations. The actual answer expands on this concept with more detail about how the heap property works and what it entails for each node in relation to its children, but both ultimately convey the same fundamental information. The factual content is consistent between the two answers, and while there are minor differences in wording, they do not alter the meaning. Both answers could be in different languages but still convey the same core information about heapify operations and maintaining the heap property.",
      "response_time": 5.700737714767456,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        171,
        177,
        180
      ],
      "language": "english"
    },
    {
      "test_id": "heap_001_bn",
      "question": "হিপ প্রপার্টি কিভাবে বজায় রাখা হয়?",
      "expected_answer": "হিপিফাই অপারেশন ব্যবহার করে প্যারেন্ট নোড এবং চাইল্ড নোডের মধ্যে হিপ প্রপার্টি বজায় রাখা হয়",
      "actual_answer": "হিপ প্রপার্টি বজায় রাখার জন্য একটি প্রথম কিছু হল সংখ্যাগুলির বিভাজন। এটি আপনার প্রথম সংখ্যা দিন, যেমন 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of a histogram, which is used to visualize data. The first answer in Bangla describes how histogths are created using Python libraries and the second one in English explains that a histogram is essentially a bar chart representing numerical data. Despite differences in language, both answers convey the same core information about creating and understanding histograms.",
      "response_time": 8.514916181564331,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        758,
        756,
        1111
      ],
      "language": "bangla"
    },
    {
      "test_id": "graph_001_en",
      "question": "What is Dijkstra's algorithm used for?",
      "expected_answer": "Finding shortest paths from a source vertex to all other vertices in weighted graphs",
      "actual_answer": "Dijkstra's algorithm is used to find the shortest path between two nodes in a graph. It is particularly useful when there are multiple paths from one node to another, and the goal is to find the shortest of these paths.",
      "success": true,
      "equivalent": false,
      "confidence": "MEDIUM",
      "explanation": "The expected answer focuses on finding the shortest paths from a source vertex to all other vertices in weighted graphs, which is typically accomplished using Dijkstra' endpoints. The actual answer discusses finding the shortest path between two nodes and does not explicitly mention all other vertices or weighted graphs, which are key concepts in the expected answer. However, Dijkstra's algorithm can be applied to both unweighted and weighted graphs, so there is some overlap in content. The difference in focus between the two answers leads to a conclusion of non-equivalence with medium confidence due to partial alignment and differences in scope.",
      "response_time": 4.685280084609985,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        679,
        723,
        682
      ],
      "language": "english"
    },
    {
      "test_id": "graph_001_bn",
      "question": "ডাইজস্ট্রার অ্যালগরিদম কি জন্য ব্যবহৃত হয়?",
      "expected_answer": "ওজনযুক্ত গ্রাফে একটি উৎস থেকে অন্যান্য সব শীর্ষে সবচেয়ে ছোট পথ খুঁজে বের করার জন্য",
      "actual_answer": "ডাইজস্ট্রার অ্যালগরিদম ব্যবহৃত হয় সাধারণ সেল এবং সাধারণ প্রতিটি সেলের উপর ভিত্তি করে। এটি বিভিন্ন সাধারণ প্রতিটি সেলের সবচেয়ে কম দুরূহ পথ অনুসারে সেলগুলি সংযোজন করে।",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of urban renewal, specifically targeting small businesses and shops in various sectors. The first answer is in Bangla, while the second one is in English but conveys a similar message about the ordinance's impact on small businesses and shops. The core information regarding urban renewal, targeting of specific sectors, and effects on small enterprises is consistent across both answers. Minor differences in wording do not alter the fundamental meaning conveyed by each answer.",
      "response_time": 8.913021087646484,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        723,
        679,
        682
      ],
      "language": "bangla"
    },
    {
      "test_id": "advanced_001_en",
      "question": "What is the master theorem?",
      "expected_answer": "A method for solving recurrence relations commonly found in divide-and-conquer algorithms",
      "actual_answer": "The master theorem is a technique used in algorithm analysis to bound the time complexity of an algorithm by considering the worst-case scenario. It states that for any algorithm with time complexity T(n) and a function f(n) such that f(n) ≤ cn, where c is a constant, the worst-case time complexity of the algorithm can be bounded by T(n) ≤ (f(n) + cn) * log(n). This theorem is used to simplify the analysis of algorithms and provide a more accurate upper bound on their time complexity.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer refers to a method for solving recurrence relations in divide-and-conquer algorithms, which is about analyzing recursive functions and finding their time complexity. The actual answer discusses the master theorem for algorithm analysis, a specific technique used to determine the upper bound of an algorithm's time complexity in terms of its worst-case scenario. While both answers deal with analyzing algorithms, they refer to different methods and concepts within the field of algorithm analysis. The expected answer is about solving recurrence relations, while the actual answer focuses on bounding time complexity using a specific theorem. Therefore, they do not convey the same core information and meaning.",
      "response_time": 5.904879808425903,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        117,
        126,
        114
      ],
      "language": "english"
    },
    {
      "test_id": "advanced_001_bn",
      "question": "মাস্টার থিওরেম কি?",
      "expected_answer": "ডিভাইড অ্যান্ড কনকার অ্যালগরিদমে পাওয়া রিকারেন্স রিলেশন সমাধানের একটি পদ্ধতি",
      "actual_answer": "মাস্টার থিওরেম একটি প্রতিটিকে দুটি সংখ্যা দিয়ে বিশ্লেষণ করার একটি পদ্ধতি। এটি সম্পূর্ণ বিশ্লেষণ করার জন্য একটি সংখ্যা দিয়ে বিশ্লেষণ করার একটি পদ্ধতি। এটি সম্পূর্ণ বিশ্লেষণ",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the same core concept of a multilingual RAG system facilitating cross-lingual dialogue. The first answer is in Bangla, while the second one is in English; however, they convey the same meaning about a method that enables communication between speakers of different languages within a dialogue system. The key concepts and factual information are consistent across both answers, with only minor differences in wording that do not affect the overall meaning conveyed.",
      "response_time": 7.679417848587036,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        117,
        126,
        117
      ],
      "language": "bangla"
    },
    {
      "test_id": "complexity_002_en",
      "question": "What is NP-completeness?",
      "expected_answer": "A class of computational problems that are among the most difficult problems in NP",
      "actual_answer": "NP-completeness is a class of problems in computational complexity theory that are known to be at least as difficult as the hardest problems in NP, which is the set of all decision problems for which the answers are \"yes\" or \"no\". This means that if a problem can be solved in polynomial time, then it is in NP, and if it is in NP, then it is at least as hard as any problem in NP. The class NP is defined as the set of all decision problems for which the answers are \"yes\" or \"no\", and it includes many practical problems such as determining whether a given graph is connected, or whether a given Turing machine halts on a given input. The class NP-complete is a subset of NP that includes the hardest problems in NP, and it is known to be at least as hard as any problem in NP. This means that if a problem",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the concept of NP-completeness, which is a class of problems that are among the most difficult in NP. The expected answer succinctly defines this concept without going into detail about computational complexity theory, while the actual answer provides a more comprehensive explanation of what NP-completeness entails. Despite these differences in depth and detail, both answers convey the same core information about the difficulty level of problems within this class relative to other NP problems. The factual information is consistent between the two, and while there are minor differences in wording, they do not alter the meaning conveyed by either answer. Both answers could be in different languages but still maintain semantic equivalence as long as the translation accurately conveys these concepts and details.",
      "response_time": 7.62336802482605,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1070,
        1090,
        1087
      ],
      "language": "english"
    },
    {
      "test_id": "complexity_002_bn",
      "question": "NP-completeness কি?",
      "expected_answer": "NP-তে সবচেয়ে কঠিন সমস্যাগুলোর একটি শ্রেণি যা গণনাগত জটিলতার ক্ষেত্রে গুরুত্বপূর্ণ",
      "actual_answer": "NP-completeness is a complexity class in computer science that represents problems that are as hard as any other problem in NP, the set of problems that can be solved in polynomial time. This means that if a solution to an NP-complete problem is found, it can be verified in polynomial time, making it computationally feasible to solve the problem.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of NP-completeness, which is a central idea in computational complexity theory. The expected answer uses Bangla to describe that an NP-complete problem's solution can be verified quickly, which aligns with the actual answer stating that if a polynomial-time solution is found for any NP-complete problem, it implies solutions can be verified in polynomial time. Despite differences in language and wording, the core information about NP-completeness remains consistent between both answers.",
      "response_time": 4.792554140090942,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1090,
        1070,
        1084
      ],
      "language": "bangla"
    },
    {
      "test_id": "negative_001_en",
      "question": "How do I cook pasta?",
      "expected_answer": "No relevant information found",
      "actual_answer": "To cook pasta, you need to follow these steps:\n\n1. Fill a large pot with water and bring it to a boil.\n2. Add the pasta to the boiling water and stir gently to prevent it from sticking together.\n3. Cook the pasta according to the package instructions, usually for 2-5 minutes depending on the type of pasta.\n4. Once cooked, drain the pasta and transfer it to a serving bowl.\n5. If desired, add any desired toppings or sauces to the pasta before serving.\n\nRemember to adjust cooking time based on the type of pasta you are using and your personal preference for al dente texture. Enjoy your pasta!",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers provide the same core information about cooking pasta, including steps for boiling water, adding and stirring pasta, cooking time based on package instructions, draining the pasta, transferring it to a serving bowl, and adding toppings or sauces if desired. The factual information is consistent between both answers. Although the wording may differ slightly due to language differences, the semantic content remains equivalent. Both instructions convey the same meaning and are likely translatable with minimal loss of information across languages.",
      "response_time": 6.651875972747803,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1074,
        133,
        1002
      ],
      "language": "english"
    },
    {
      "test_id": "negative_001_bn",
      "question": "আমি কিভাবে পাস্তা রান্না করব?",
      "expected_answer": "কোন প্রাসঙ্গিক তথ্য পাওয়া যায়নি",
      "actual_answer": "পাস্তা রান্না করার জন্য আপনি একটি পাস্তা বিভাগ চালু করতে পারেন। এটি আপনার পাস্তা বিভাগের জন্য একটি স্থানীয় পাস্তা বিভাগের উপর ভিত্তি করে চালু হয়। এটি আপনার পাস্তা বিভাগের জন",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the concept of joining a club as an act of kindness towards others. The expected answer translates to \"Can't anyone join this social group?\" in English, which implies inclusivity and openness within a club setting. The actual answer, translated into English as \"Can't anyone join this patron group?\", also communicates the same idea of inviting others to become part of a club. Despite minor differences in wording, both answers convey the core message that joining is an act of kindness and are semantically equivalent. The confidence level is high due to clear semantic equivalence despite potential language nuances.",
      "response_time": 7.830629110336304,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1074,
        133,
        1002
      ],
      "language": "bangla"
    },
    {
      "test_id": "negative_002_en",
      "question": "What is the weather today?",
      "expected_answer": "No relevant information found",
      "actual_answer": "I'm sorry, but I cannot answer this question as I am an AI language model and do not have access to real-time information. Please provide me with a specific location or weather forecast, and I will be happy to assist you with the weather conditions there.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers acknowledge the limitation of not having real-time access to information. The actual answer provides a direct response by offering an alternative way to obtain weather information, which aligns with the expected answer's intent of not being able to provide specific forecast details. The core message is consistent across both answers despite minor differences in wording, and the semantic equivalence holds true even if they are presented in different languages (English/Bangla). The confidence level is high because both answers effectively communicate the same fundamental message.",
      "response_time": 4.134408235549927,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        609,
        169,
        614
      ],
      "language": "english"
    }
  ]
}