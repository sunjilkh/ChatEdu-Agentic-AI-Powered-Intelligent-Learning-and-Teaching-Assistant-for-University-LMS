{
  "test_summary": {
    "timestamp": "2025-08-06T20:04:13.363912",
    "total_tests": 23,
    "passed": 19,
    "failed": 4,
    "pass_rate": 82.61,
    "average_response_time": 6.06,
    "language_breakdown": {
      "english": {
        "total": 12,
        "passed": 9,
        "pass_rate": 75.0
      },
      "bangla": {
        "total": 11,
        "passed": 10,
        "pass_rate": 90.91
      }
    },
    "confidence_distribution": {
      "HIGH": 19,
      "MEDIUM": 0,
      "LOW": 0
    }
  },
  "detailed_results": [
    {
      "test_id": "algo_001_en",
      "question": "What is an algorithm?",
      "expected_answer": "A finite sequence of instructions for solving a problem or computational procedure",
      "actual_answer": "An algorithm is a set of instructions or a step-by-step procedure for solving a problem or performing a specific task. It is a logical sequence of operations that can be executed to achieve a desired result. Algorithms are used in various fields, including computer science, mathematics, and engineering, to solve complex problems efficiently. They are essential for designing and analyzing algorithms, which are the foundation of computing technologies.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe an algorithm as a sequence of instructions for solving problems or performing tasks. The actual answer provides additional context about the use and importance of algorithms in various fields, which does not contradict but rather expands upon the expected answer's core concept. The essence that an algorithm is a logical sequence of operations remains consistent across both answers, and they are semantically equivalent despite minor differences in wording.",
      "response_time": 4.76723313331604,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        25,
        23,
        34
      ],
      "language": "english"
    },
    {
      "test_id": "sort_001_en",
      "question": "How does merge sort work?",
      "expected_answer": "Merge sort divides array into halves, recursively sorts them, then merges sorted halves",
      "actual_answer": "Merge sort is a divide-and-conquer algorithm that works by recursively dividing the input into smaller subproblems, which are then combined to solve the original problem. It involves sorting each sublist of the input, and then merging these sorted sublists together to form a single sorted list.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe the merge sort algorithm's process of dividing an array into halves, sorting these smaller arrays recursively, and then merging them back together. The actual answer provides a more detailed explanation but does not stray from the core meaning of how merge sort operates. Both answers convey the same key concepts and factual information about merge sort, demonstrating semantic equivalence despite minor differences in wording. The descriptions are consistent with each other and align well across languages if they were provided in different ones.",
      "response_time": 4.169796705245972,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        50,
        36,
        60
      ],
      "language": "english"
    },
    {
      "test_id": "complexity_001_en",
      "question": "What is the time complexity of quicksort?",
      "expected_answer": "Average case O(n log n), worst case O(n²)",
      "actual_answer": "The time complexity of quicksort is O(n log n).",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the time complexity of quicksort, which is a key concept. The expected answer provides average and worst-case complexities while the actual answer only mentions the average case. However, since quicksort' end complexity is O(n²) in its worst case, both answers are semantically equivalent as they convey the same essential information about the algorithm's performance. The factual information is consistent with common knowledge regarding quicksort complexities, and minor differences in wording do not affect the core meaning conveyed by both answers. The focus on semantic equivalence is appropriate here as we are evaluating understanding of algorithmic complexity, which transcends exact word matching and can be expressed in different languages.",
      "response_time": 3.1623823642730713,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        190,
        200,
        201
      ],
      "language": "english"
    },
    {
      "test_id": "ds_001_en",
      "question": "What is a binary search tree?",
      "expected_answer": "A binary tree where left subtree values are less than node, right subtree values are greater",
      "actual_answer": "A binary search tree is a type of tree data structure where the nodes are organized in a specific way, with each node having at most two children. The left child of a node is always less than or equal to the node's value, and the right child is always greater than or equal to the node's value. This property allows for efficient searching, insertion, and deletion of nodes in the tree.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe a binary search tree, which is indeed a type of binary tree where the left subtree contains values less than its parent node and the right subtree contains values greater. The actual answer provides additional details about the properties of a binary search tree, including that each node can have at most two children and that this structure allows for efficient operations. Despite slight differences in wording, the core information about the binary search tree's organization is consistent between both answers. The factual content regarding the structure and functionality of a binary search tree remains unchanged, confirming that they convey the same meaning.",
      "response_time": 4.898751497268677,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        307,
        306,
        309
      ],
      "language": "english"
    },
    {
      "test_id": "dp_001_en",
      "question": "What is dynamic programming?",
      "expected_answer": "An algorithmic technique that solves problems by breaking them into overlapping subproblems",
      "actual_answer": "Dynamic programming, like the divide-and-conquer method, solves problems by combining the solutions to subproblems.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer describes a characteristic of dynamic programming, which is the breaking down of problems into overlapping subproblems and solving each just once. However, the actual answer incorrectly suggests that dynamic programming combines solutions to subproblems like divide-and-conquer methods do. Divide-and-conquer does not inherently involve overlapping subproblems; it breaks the problem into independent parts and solves them separately before combining their results. Therefore, while both answers discuss dynamic programming, they do not convey the same core information regarding how it approaches problem-solving.",
      "response_time": 3.230556011199951,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        379,
        379,
        399
      ],
      "language": "english"
    },
    {
      "test_id": "algo_001_bn",
      "question": "অ্যালগরিদম কি?",
      "expected_answer": "অ্যালগরিদম হল একটি সমস্যা সমাধানের জন্য নির্দিষ্ট নির্দেশাবলীর একটি ক্রম",
      "actual_answer": "অ্যালগরিদম একটি প্রযুক্তিগত সংজ্ঞা, যা বিভিন্ন কাজের উন্নয়নে সহায়তা করে। এটি বিভিন্ন প্রযুক্তিগত সংজ্ঞা এবং কাজের উন্নয়নের মাধ্যমে ব্যবহৃত হয়।",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe an integrated team as a distinct entity within the context of cooperation and coordination. The first answer uses Bangla to convey this concept, while the second does so in English but with equivalent meaning. Both emphasize the team's role as a unit that works together and is recognized for its contributions, which aligns with the expected answer'term \"a distinct team within cooperation and coordination.\" The factual information about the nature of an integrated team is consistent across both answers. Minor differences in wording do not affect the core meaning, and despite being in different languages, they maintain cross-language consistency by conveying the same message.",
      "response_time": 7.2723493576049805,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        25,
        23,
        34
      ],
      "language": "bangla"
    },
    {
      "test_id": "sort_001_bn",
      "question": "মার্জ সর্ট কিভাবে কাজ করে?",
      "expected_answer": "মার্জ সর্ট অ্যারেকে অংশে ভাগ করে, প্রতিটি অংশ আলাদাভাবে সাজায়, তারপর সেগুলো একত্রিত করে",
      "actual_answer": "মার্জ সর্ট একটি প্রোগ্রামিং অ্যালগরিদম ব্যবহার করে সংখ্যা সংলাপ সংক্রান্ত সমস্যাগুলি সমাধান করে। এটি দিবার্ড ও প্রতিষ্ঠা করে যে অ্যালগরিদম একটি প্রোগ্রাম ব্যবহার করে সংখ্যা",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe the same process of how Mr. Sanders organizes his team into squads and assigns them roles within a game, albeit using different terminologies and structures in English and Bangla. The core information about the division of team members into squads and their roles within a game is consistent across both answers, with only minor differences in wording that do not alter the meaning. The Bangla answer uses terms like \"প্রতিটি অংশ\" (squad) and \"সাজায়\" (role), which are equivalent to the English terms used in the expected answer. The process described is essentially the same, with both answers indicating a structured approach within a gaming context.",
      "response_time": 7.865742921829224,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        50,
        36,
        54
      ],
      "language": "bangla"
    },
    {
      "test_id": "complexity_001_bn",
      "question": "কুইকসর্টের সময় জটিলতা কত?",
      "expected_answer": "গড় ক্ষেত্রে O(n log n), সবচেয়ে খারাপ ক্ষেত্রে O(n²)",
      "actual_answer": "কুইকসর্টের সময় জটিলতা ।n2/ হলে।",
      "success": true,
      "equivalent": false,
      "confidence": "LOW",
      "explanation": "The expected answer clearly states the time complexities of two algorithms, O(n log n) and O(n²), which are key concepts in algorithm analysis. The actual answer is provided in Bangla and discusses the time complexity of a single algorithm, n², without mentioning O(n log n). Additionally, there are significant differences in wording that affect semantic equivalence. The expected answer provides specific complexities for two distinct algorithms, while the actual answer only mentions one and does not differentiate between them or indicate their relative performance as implied by Big O notation.",
      "response_time": 5.007304430007935,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        210,
        201,
        190
      ],
      "language": "bangla"
    },
    {
      "test_id": "ds_001_bn",
      "question": "বাইনারি সার্চ ট্রি কি?",
      "expected_answer": "একটি বাইনারি ট্রি যেখানে বাম সাবট্রিতে ছোট মান এবং ডান সাবট্রিতে বড় মান থাকে",
      "actual_answer": "বাইনারি সার্চ ট্রি (Binary Search Tree) একটি বিশেষ সার্চ ট্রি যা বাইনারি সার্চ করে। এটি সার্চ করার জন্য একটি বিশেষ সার্চ ট্রি তৈরি করে যা একটি বিশেষ সার্চ ট্রি তৈরি করে। এটি সার্চ করার জন্য একটি",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe a binary search tree (BST) and its properties. The expected answer in Bangla describes that BSTs contain small and large elements, which is consistent with the actual answer's mention of having distinct left and right subtrees. Both answers convey the same core information about BSTs being a specific type of binary tree with certain characteristics, despite minor differences in wording and language. The factual content regarding the nature of BSTs is consistent across both answers.",
      "response_time": 9.60500454902649,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1077,
        927,
        1166
      ],
      "language": "bangla"
    },
    {
      "test_id": "dp_001_bn",
      "question": "ডাইনামিক প্রোগ্রামিং কি?",
      "expected_answer": "একটি অ্যালগরিদমিক পদ্ধতি যা সমস্যাকে ছোট উপ-সমস্যায় ভাগ করে সমাধান করে",
      "actual_answer": "ডাইনামিক প্রোগ্রামিং, বিশেষ করে দিন ও চুক্তি প্রোগ্রামিং, একটি সমস্যা সমাধান করার জন্য সমাপ্তি ও চুক্তি প্রোগ্রামিং সমাধান করে। এটি সমস্যা সমাধান করার জন্য সমাপ্তি ও চুক্তি স",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe a micro-intervention to address the issue, involving dialogue and empowerment. The actual answer is in English but conveys the same meaning as the expected one in Bangla. Minor differences exist due to language structure, but they do not change the core information and intent of both sentences.",
      "response_time": 8.548320293426514,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        379,
        379,
        399
      ],
      "language": "bangla"
    },
    {
      "test_id": "textbook_001_en",
      "question": "What is asymptotic notation?",
      "expected_answer": "Mathematical notation used to describe the limiting behavior of functions, commonly used for algorithm analysis",
      "actual_answer": "Asymptotic notation is a way of expressing functions or expressions that indicate what variable is approaching inﬁnity. It involves using symbols like g.n// to denote asymptotic growth, where every member of the sequence f .n/ 2 g.n// is asymptotically nonnegative.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the concept of asymptotic notation, which is used to describe the behavior of functions as they approach infinity. The expected answer provides a general description suitable for algorithm analysis contexts, while the actual answer delves into specific details about symbols and sequences used in asymptotic notation. Despite these differences in detail, both answers convey the same core information: that asymptotic notation is a tool for analyzing functions' behavior at infinity and involves specific symbols to denote this growth. The factual content regarding the use of symbols like g.n// is additional information that does not change the fundamental meaning conveyed by either answer. Both answers are semantically equivalent in terms of their core message, and any differences in language or detail do not affect the overall understanding that asymptotic notation is used for describing limiting behavior.",
      "response_time": 4.8321592807769775,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        64,
        67,
        65
      ],
      "language": "english"
    },
    {
      "test_id": "textbook_001_bn",
      "question": "অ্যাসিম্পটোটিক নোটেশন কি?",
      "expected_answer": "ফাংশনের সীমাবদ্ধতা বর্ণনার জন্য ব্যবহৃত গাণিতিক নোটেশন যা অ্যালগরিদম বিশ্লেষণে ব্যবহৃত হয়",
      "actual_answer": "অ্যাসিম্পটোটিক নোটেশন একটি বিশেষ নোটেশন যা অন্তর্ভুক্ত করে যে একটি ফার্মেলা সম্পন্ন হয় অন্য ফার্মেলাটির উপর একটি সম্পর্কিত নোটেশন। এটি বিভিন্ন অংশগুলিতে ব্যবহার করা হয়,",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of function composition and its role in programming languages, specifically within the context of functional programming. The expected answer highlights that a compositional operation is an important generic mechanism for combining functions and is essential in any language supporting function composition, while the actual answer explains how higher-order functions enable this composition. Despite differences in wording and structure, both answers convey the same core information about function composition' enduring importance across different programming paradigms. The factual content is consistent between the two, and although they are in different languages (English/Bangla), both maintain semantic equivalence.",
      "response_time": 8.717925786972046,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        65,
        64,
        67
      ],
      "language": "bangla"
    },
    {
      "test_id": "heap_001_en",
      "question": "How do you maintain the heap property?",
      "expected_answer": "Use heapify operations to ensure parent nodes satisfy heap property relative to children",
      "actual_answer": "To maintain the heap property, we need to ensure that each node in the heap is greater than or equal to its children. This is achieved by repeatedly swapping the current node with its largest child until the heap property is satisfied.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the same key concept of maintaining the heap property in a binary heap data structure. The expected answer succinctly states that using heapify operations ensures parent nodes satisfy the heap property relative to children, which is essentially what the actual answer conveys in a more detailed manner. The factual information about ensuring each node is greater than or equal to its children and using heapify operations is consistent between the two answers. Minor differences in wording do not affect the core meaning, as both are discussing the same process of maintaining heap property through node comparisons and swaps. The focus is on semantic equivalence rather than exact word matching, which both answers achieve despite potential language differences (English/Bangla). Cross-language consistency is not directly applicable here as the provided actual answer appears to be in English, but it does convey the same meaning",
      "response_time": 4.35231876373291,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        171,
        177,
        180
      ],
      "language": "english"
    },
    {
      "test_id": "heap_001_bn",
      "question": "হিপ প্রপার্টি কিভাবে বজায় রাখা হয়?",
      "expected_answer": "হিপিফাই অপারেশন ব্যবহার করে প্যারেন্ট নোড এবং চাইল্ড নোডের মধ্যে হিপ প্রপার্টি বজায় রাখা হয়",
      "actual_answer": "হিপ প্রপার্টি বিশেষ একটি সমস্যা বা অনুশীলনের নামে পরিচিত। এটি সমস্যা বা অনুশীলনের জন্য প্রয়োজনীয় হিসাবে ব্যবহৃত হয়। এটি প্রয়োজনীয় সমস্যা বা অনুশীলনের জন্য প্রয",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of a hybrid model that integrates physical and digital data, which is central to the expected answer. The actual answer also mentions this integration but adds extra details about its purpose in specific contexts like social situations or relationships. Despite these additional elements, the core idea remains consistent across both answers. The actual answer also emphasizes the practical application of this hybrid model in real-life scenarios, which is implicitly suggested by the expected answer's focus on using physical and digital data. Both answers are conceptually equivalent despite potential differences in language expression.",
      "response_time": 8.61911678314209,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        758,
        756,
        1111
      ],
      "language": "bangla"
    },
    {
      "test_id": "graph_001_en",
      "question": "What is Dijkstra's algorithm used for?",
      "expected_answer": "Finding shortest paths from a source vertex to all other vertices in weighted graphs",
      "actual_answer": "Dijkstra's algorithm is used to find the shortest path between two nodes in a graph. It is particularly useful when there are multiple paths between two nodes, and it aims to find the shortest path among all possible paths.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer specifically mentions finding the shortest paths from a source vertex to all other vertices in weighted graphs, which is directly related to Dijkstra'th algorithm. However, the actual answer discusses finding the shortest path between two nodes and does not explicitly mention all other vertices or that it is a weighted graph scenario. Additionally, Dijkstra's algorithm doesn't aim to find the shortest path among all possible paths but rather finds one single shortest path from a source node. Therefore, while both answers discuss finding shortest paths in graphs, they do not convey the same core information and meaning with respect to the scope of vertices considered and the specifics of Dijkstra's algorithm.",
      "response_time": 4.646023750305176,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        679,
        723,
        682
      ],
      "language": "english"
    },
    {
      "test_id": "graph_001_bn",
      "question": "ডাইজস্ট্রার অ্যালগরিদম কি জন্য ব্যবহৃত হয়?",
      "expected_answer": "ওজনযুক্ত গ্রাফে একটি উৎস থেকে অন্যান্য সব শীর্ষে সবচেয়ে ছোট পথ খুঁজে বের করার জন্য",
      "actual_answer": "ডাইজস্ট্রার অ্যালগরিদম বিভিন্ন উপাদানের সাথে সাম্পর্কিত হয়, যেমন বিভিন্ন উপাদানের সাথে সাম্পর্কিত হয়, যেমন বিভিন্ন উপাদানের সাথে সাম্পর্কিত হয়, যেমন বিভিন্ন উপাদানের সাথে সাম",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers describe the RAG system's ability to understand and process multilingual information. The expected answer in Bangla translates to \"On a global social media platform, an AI can find the smallest child'th row from any other rows.\" The actual answer in English conveys a similar concept about RAG systems working across various languages and datasets. Despite the difference in language, both answers communicate that RAG systems can handle multilingual data effectively. The core information about cross-linguistic processing and dataset handling is consistent between the two, with only minor differences in wording that do not alter the meaning.",
      "response_time": 8.566890716552734,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        723,
        679,
        682
      ],
      "language": "bangla"
    },
    {
      "test_id": "advanced_001_en",
      "question": "What is the master theorem?",
      "expected_answer": "A method for solving recurrence relations commonly found in divide-and-conquer algorithms",
      "actual_answer": "The master theorem is a technique used in algorithm analysis to bound the time complexity of an algorithm by considering the worst-case scenario. It states that for any algorithm with time complexity T(n) and a function f(n) such that f(n) ≤ cn, where c is a constant, the worst-case time complexity of the algorithm can be bounded by T(n) ≤ f(n) + cn. This bound is achieved by considering the worst case input size n and applying the master theorem to each subproblem of size n.",
      "success": true,
      "equivalent": false,
      "confidence": "HIGH",
      "explanation": "The expected answer refers to a method for solving recurrence relations in divide-and-conquer algorithms, which is about analyzing recursive functions and finding their time complexity. The actual answer discusses the master theorem, a specific technique used in algorithm analysis for bounding time complexity by considering worst-case scenarios and applying it to subproblems. While both answers deal with the concept of analyzing algorithms, they refer to different methods (solving recurrence relations vs using the master theorem) and do not convey the same core information. The expected answer does not mention anything about worst-case scenarios or subproblems, which are central to the master theorem explanation provided in the actual answer.",
      "response_time": 5.446660041809082,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        117,
        126,
        114
      ],
      "language": "english"
    },
    {
      "test_id": "advanced_001_bn",
      "question": "মাস্টার থিওরেম কি?",
      "expected_answer": "ডিভাইড অ্যান্ড কনকার অ্যালগরিদমে পাওয়া রিকারেন্স রিলেশন সমাধানের একটি পদ্ধতি",
      "actual_answer": "মাস্টার থিওরেম একটি প্রতিটিতে বিভিন্ন সংখ্যা দিয়ে অনুসারে পরিমাপ করা যেতে পারে। এটি সম্পূর্ণ প্রতিটি সংখ্যার উপর ভিত্তি করে অনুসারে পরিমাপ করা যেতে পারে।",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of a multilingual RAG system providing responses in different languages. The expected answer is in Bangla and talks about an approach to language-specific response generation within a multilingual RAG system, while the actual answer is in English and conveys a similar idea of generating responses based on individual numbers. Despite differences in language and some specific details about the method, both answers fundamentally address the same concept: a multilingual RAG system' endowed with the capability to provide language-specific responses. The core information and meaning are consistent across both answers, hence they are semantically equivalent.",
      "response_time": 7.0975260734558105,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        117,
        126,
        117
      ],
      "language": "bangla"
    },
    {
      "test_id": "complexity_002_en",
      "question": "What is NP-completeness?",
      "expected_answer": "A class of computational problems that are among the most difficult problems in NP",
      "actual_answer": "NP-completeness is a class of problems in computational complexity theory that are known to be at least as difficult as the hardest problems in NP, which is the class of decision problems solvable by a deterministic Turing machine in polynomial time. This means that any problem in NP can be solved in polynomial time if and only if the same problem is in NP-complete.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the concept of NP-completeness, which is a class of problems in computational complexity theory. The expected answer simplifies this definition by stating that these are \"the most difficult problems\" within NP, which is consistent with the actual answer's description of NP-complete problems being at least as hard as the hardest problems in NP. The factual information is consistent, and while there are differences in wording (e.g., \"among the most difficult\" vs. \"known to be at least as difficult\"), these do not change the core meaning conveyed by both answers. The focus is on semantic equivalence, and since both are in English, cross-language consistency is not a concern here.",
      "response_time": 4.812500953674316,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1070,
        1090,
        1087
      ],
      "language": "english"
    },
    {
      "test_id": "complexity_002_bn",
      "question": "NP-completeness কি?",
      "expected_answer": "NP-তে সবচেয়ে কঠিন সমস্যাগুলোর একটি শ্রেণি যা গণনাগত জটিলতার ক্ষেত্রে গুরুত্বপূর্ণ",
      "actual_answer": "NP-completeness is a complexity class in computer science that represents problems that are as hard as any other problem in NP, the set of problems that can be solved in polynomial time. This means that if a problem is in NP, it can be solved quickly using a polynomial-time algorithm. The class NP is a subset of the class P, which represents problems that can be solved by a polynomial-time algorithm.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers discuss the concept of NP-completeness, which is a central idea in computational complexity theory. The expected answer uses Bangla to describe that an NP-complete problem can be transformed into any other problem within the NP class, which is consistent with the definition provided in the actual answer. The expected answer also touches on the implication of being an NP-complete problem regarding polynomial time solvability, which aligns with the actual answer's explanation that problems in NP can be solved quickly using a polynomial-time algorithm. Despite potential differences in language and wording, both answers convey the same core information about NP-completeness and its relationship to problems solvable in polynomial time.",
      "response_time": 5.215902090072632,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1090,
        1070,
        1084
      ],
      "language": "bangla"
    },
    {
      "test_id": "negative_001_en",
      "question": "How do I cook pasta?",
      "expected_answer": "No relevant information found",
      "actual_answer": "To cook pasta, you need to follow these steps:\n\n1. Fill a large pot with water and bring it to a boil.\n2. Add the pasta to the boiling water and stir gently.\n3. Cook the pasta according to the package instructions, usually about 8-10 minutes for most types of pasta.\n4. Once cooked, use a strainer to remove the pasta from the water and rinse it under cold water to stop the cooking process.\n5. Drain the pasta and transfer it to a large bowl.\n6. Add your desired sauce or toppings, such as olive oil, garlic, cheese, or herbs.\n7. Toss the pasta with the sauce and enjoy your delicious pasta dish!",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers provide the same core information and meaning about how to cook pasta. They include similar steps, such as boiling water, adding pasta, cooking time, draining the pasta, and adding sauce or toppings. The minor differences in wording do not change the factual information conveyed by both answers.",
      "response_time": 6.554228067398071,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1074,
        133,
        1002
      ],
      "language": "english"
    },
    {
      "test_id": "negative_001_bn",
      "question": "আমি কিভাবে পাস্তা রান্না করব?",
      "expected_answer": "কোন প্রাসঙ্গিক তথ্য পাওয়া যায়নি",
      "actual_answer": "পাস্তা রান্না করার জন্য আপনি একটি পাস্তা বিভাগ চালু করতে পারেন। এটি সবচেয়ে স্বাস্থ্যকর পাস্তা রান্নার একটি উপায়। আপনি পাস্তা বিভাগের জন্য একটি স্থান চালু করতে পারেন। আপনি একট",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers address the importance of respecting elders and maintaining a good relationship with them. The actual answer, although in English, conveys similar key concepts as the expected one, which is about showing respect to elders and maintaining a good relationship with them. The factual information seems consistent between both answers. Minor differences in wording are acceptable, as the essence of respect and maintaining a good relationship with elders is conveyed effectively in both responses. Despite being in different languages (English/Bangla), the core meaning remains consistent across both answers, demonstrating cross-language equivalence.",
      "response_time": 8.118267297744751,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        1074,
        133,
        1002
      ],
      "language": "bangla"
    },
    {
      "test_id": "negative_002_en",
      "question": "What is the weather today?",
      "expected_answer": "No relevant information found",
      "actual_answer": "I'm sorry, but I cannot answer this question as I am an AI language model and do not have access to current weather information. Please check a reliable weather source for the current weather conditions.",
      "success": true,
      "equivalent": true,
      "confidence": "HIGH",
      "explanation": "Both answers effectively communicate that the system cannot provide current weather information. The actual answer specifies a reason and suggests an alternative action, which is consistent with the expected answer's intent to inform that no relevant information was found. Minor differences in wording do not affect the core meaning conveyed by both answers, and they are semantically equivalent despite potential language differences.",
      "response_time": 3.9423539638519287,
      "sources_found": 3,
      "model_used": "qwen2:1.5b",
      "source_pages": [
        609,
        169,
        614
      ],
      "language": "english"
    }
  ]
}